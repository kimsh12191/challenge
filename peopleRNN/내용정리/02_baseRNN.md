# Input 데이터셋 구축하기

일단은 데이터에 구멍이 뻥뻥 뚫려있으니까 그냥 그대로 RNN에 넣을 순없다. 동시에 RNN을 위해서는 30일 정도간격의 window도 만들어야하고, TestSet도 결정해주어야 한다.
일단 testSet은 구멍이 뚫여있는 바로 앞의날짜를 사용한다. (그 바로다음이 우리가 문제를 풀기위해 맞출부분이니까 의미가 있을거라 생각함) 또한 window 안에 식수인원이 0이 들어가지 않도록 구성을 한다.

아래처럼 데이터를 가지고 옴. `orderDf`가 같은 친구안에서 33개씩 윈도우(30개 RNN input 3개 예측)를 sliding 하면서 데이터 추출

```
| index  |   date	    |    count	   | weekday  |	orderDf  |
| 1	| 2003-03-02	| 33.357401   | 	   6	   |    0  |
| 2	| 2003-03-03	| 58.483755   | 	   0	   |    0  |
| 3	| 2003-03-04	| 59.350181   | 	   1	   |    0  |
| 4	| 2003-03-05	| 52.635379   | 	   2	   |    0  |
```



# 요일정보 반영

요일을 one hot encoder를 사용해서 [1, 0, 0, 0, 0, 0, 0] 이런식으로 바꿔준 후에 그날에 해당하는 식수인원을 곱해줌으로써 input 형태로 만든다. RNN에 들어가는 trainX의 경우 [n_batch, window(30), week(7)] 의 shape를 지닌다. 아래는 input 예제

```python
array([[ 0.        ,  0.        ,  0.        ,  0.        ,  0.        , 0.        , 33.35740072]])
   ```


# 미리보는 RNN결과

RNN 구성은 중요하다고생각하지는 않고, RMSE가 대략 4정도 나오는데 평균 식수인원이 40정도이므로 (딱히 좋은성능은 아님) 딱 표준편차많큼 나왔다. 나머지 부분을 메뉴를 잘 이용해서 추가보정을 해야한다.

예측의 경우 30일 데이터를 이용하여 31번쨰 식수인원을 예측하고 [2-31]일데이터로 32번쨰 식수인원예측, 마지막으로 [3-32]일데이터로 최종적으로 알고싶은 33번쨰 식수인원을 예측한다.
